/* File: PcSeg.cs
** Project: MusicTheory
** Author: Jeffrey Martin
**
** This file contains the implementation of the PcSeg class.
**
** Copyright © 2021 by Jeffrey Martin. All rights reserved.
** Email: jmartin@jeffreymartincomposer.com
** Website: https://jeffreymartincomposer.com
**
******************************************************************************
**
** This program is free software: you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation, either version 3 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;

namespace MusicTheory
{
    /// <summary>
    /// Contains functions for working with pcsegs
    /// </summary>
    public static class PcSeg
    {
        /// <summary>
        /// Gets the BIP_n of a list of set-classes generated by IMB_n
        /// </summary>
        /// <param name="imb_n">The list of imbricated set-classes</param>
        /// <returns>The BIP_n</returns>
        public static List<int> bip_n(List<PcSetClass> imb_n)
        {
            List<int> bip = new List<int>();

            if (imb_n.Count > 0)
            {
                foreach (PcSetClass sc in imb_n)
                    bip.Add(int.Parse(sc.ForteName.Split('-')[1].Trim('Z')));

                bip.Sort();
            }

            return bip;
        }

        /// <summary>
        /// Gets the complement of a pcseg
        /// </summary>
        /// <param name="pcseg">The pcseg</param>
        /// <returns>The complement</returns>
        public static List<PitchClass> Complement(List<PitchClass> pcseg)
        {
            List<PitchClass> list = new List<PitchClass>();
            Dictionary<int, char> usedPitches = new Dictionary<int, char>();
            foreach (PitchClass pc in pcseg)
                usedPitches[pc.PitchClassInteger] = '0';
            for (int i = 0; i < 12; i++)
            {
                if (!usedPitches.ContainsKey(i))
                    list.Add(new PitchClass(i));
            }
            return list;
        }

        /// <summary>
        /// Gets the complement of a pcseg
        /// </summary>
        /// <param name="pcseg">The pcseg</param>
        /// <returns>The complement</returns>
        public static List<PitchClass24> Complement(List<PitchClass24> pcseg)
        {
            List<PitchClass24> list = new List<PitchClass24>();
            Dictionary<int, char> usedPitches = new Dictionary<int, char>();
            foreach (PitchClass24 pc in pcseg)
                usedPitches[pc.PitchClassInteger] = '0';
            for (int i = 0; i < 24; i++)
            {
                if (!usedPitches.ContainsKey(i))
                    list.Add(new PitchClass24(i));
            }
            return list;
        }

        /// <summary>
        /// Copies a pitch class list
        /// </summary>
        /// <param name="list">A list</param>
        /// <returns>A copy of the list</returns>
        private static List<PitchClass> CopyList(List<PitchClass> list)
        {
            List<PitchClass> newList = new List<PitchClass>(list.Capacity);
            foreach (PitchClass pc in list)
                newList.Add(new PitchClass(pc));
            return newList;
        }

        /// <summary>
        /// Copies a pitch class list
        /// </summary>
        /// <param name="list">A list</param>
        /// <returns>A copy of the list</returns>
        private static List<PitchClass24> CopyList(List<PitchClass24> list)
        {
            List<PitchClass24> newList = new List<PitchClass24>(list.Capacity);
            foreach (PitchClass24 pc in list)
                newList.Add(new PitchClass24(pc));
            return newList;
        }

        /// <summary>
        /// Gets all secondary forms that contain the provided ordered sequence of pitch classes
        /// </summary>
        /// <param name="pitches">An ordered sequence of pitch classes</param>
        /// <returns>A collection of secondary forms</returns>
        public static List<Pair<string, List<PitchClass>>> GetSecondaryForms(List<PitchClass> pcseg, List<PitchClass> pitches)
        {
            List<Pair<string, List<PitchClass>>> secondaryForms = new List<Pair<string, List<PitchClass>>>();

            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> transpose = Transpose(pcseg, i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (transpose[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (transpose[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString(), transpose));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> invert = Transpose(Invert(pcseg), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (invert[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (invert[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString() + 'I', invert));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> retrograde = Transpose(Retrograde(pcseg), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (retrograde[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (retrograde[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString() + 'R', retrograde));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> retrogradeInverse = Transpose(Retrograde(Invert(pcseg)), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (retrogradeInverse[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (retrogradeInverse[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString() + "RI", retrogradeInverse));
                    }
                    if (!isValid)
                        break;
                }
            }
            return secondaryForms;
        }

        /// <summary>
        /// Gets all secondary forms that contain the provided ordered sequence of pitch classes
        /// </summary>
        /// <param name="pitches">An ordered sequence of pitch classes</param>
        /// <returns>A collection of secondary forms</returns>
        public static List<Pair<string, List<PitchClass24>>> GetSecondaryForms(List<PitchClass24> pcseg, List<PitchClass24> pitches)
        {
            List<Pair<string, List<PitchClass24>>> secondaryForms = new List<Pair<string, List<PitchClass24>>>();

            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> transpose = Transpose(pcseg, i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (transpose[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (transpose[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString(), transpose));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> invert = Transpose(Invert(pcseg), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (invert[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (invert[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString() + 'I', invert));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> retrograde = Transpose(Retrograde(pcseg), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (retrograde[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (retrograde[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString() + 'R', retrograde));
                    }
                    if (!isValid)
                        break;
                }
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> retrogradeInverse = Transpose(Retrograde(Invert(pcseg)), i);
                bool isValid = true;
                for (int j = 0; j < pcseg.Count - pitches.Count; j++)
                {
                    if (retrogradeInverse[j].PitchClassInteger == pitches[0].PitchClassInteger)
                    {
                        for (int k = j + 1; k - j < pitches.Count; k++)
                        {
                            if (retrogradeInverse[k].PitchClassInteger != pitches[k - j].PitchClassInteger)
                            {
                                isValid = false;
                                break;
                            }
                        }
                        if (isValid)
                            secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString() + "RI", retrogradeInverse));
                    }
                    if (!isValid)
                        break;
                }
            }
            return secondaryForms;
        }

        /// <summary>
        /// Gets all secondary forms that contain the provided unordered sequence of pitch classes
        /// </summary>
        /// <param name="pitches">An ordered sequence of pitch classes</param>
        /// <returns>A collection of secondary forms</returns>
        public static List<Pair<string, List<PitchClass>>> GetSecondaryFormsUnordered(List<PitchClass> pcseg, List<PitchClass> pitches)
        {
            List<Pair<string, List<PitchClass>>> secondaryForms = new List<Pair<string, List<PitchClass>>>();

            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> transpose = Transpose(pcseg, i);
                HashSet<PitchClass> transposeSet = ToPcSet(transpose);
                bool isValid = true;

                foreach (PitchClass pc in pitches)
                {
                    if (!transposeSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString(), transpose));
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> invert = Transpose(Invert(pcseg), i);
                HashSet<PitchClass> invertSet = ToPcSet(invert);
                bool isValid = true;

                foreach (PitchClass pc in pitches)
                {
                    if (!invertSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString(), invert));
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> retrograde = Transpose(Retrograde(pcseg), i);
                HashSet<PitchClass> retrogradeSet = ToPcSet(retrograde);
                bool isValid = true;

                foreach (PitchClass pc in pitches)
                {
                    if (!retrogradeSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString(), retrograde));
            }
            for (int i = 0; i < 12; i++)
            {
                List<PitchClass> retrogradeInverse = Transpose(Retrograde(Invert(pcseg)), i);
                HashSet<PitchClass> riSet = ToPcSet(retrogradeInverse);
                bool isValid = true;

                foreach (PitchClass pc in pitches)
                {
                    if (!riSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass>>('T' + i.ToString(), retrogradeInverse));
            }
            return secondaryForms;
        }

        /// <summary>
        /// Gets all secondary forms that contain the provided unordered sequence of pitch classes
        /// </summary>
        /// <param name="pitches">An ordered sequence of pitch classes</param>
        /// <returns>A collection of secondary forms</returns>
        public static List<Pair<string, List<PitchClass24>>> GetSecondaryFormsUnordered(List<PitchClass24> pcseg, List<PitchClass24> pitches)
        {
            List<Pair<string, List<PitchClass24>>> secondaryForms = new List<Pair<string, List<PitchClass24>>>();

            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> transpose = Transpose(pcseg, i);
                HashSet<PitchClass24> transposeSet = ToPcSet(transpose);
                bool isValid = true;

                foreach (PitchClass24 pc in pitches)
                {
                    if (!transposeSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString(), transpose));
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> invert = Transpose(Invert(pcseg), i);
                HashSet<PitchClass24> invertSet = ToPcSet(invert);
                bool isValid = true;

                foreach (PitchClass24 pc in pitches)
                {
                    if (!invertSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString(), invert));
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> retrograde = Transpose(Retrograde(pcseg), i);
                HashSet<PitchClass24> retrogradeSet = ToPcSet(retrograde);
                bool isValid = true;

                foreach (PitchClass24 pc in pitches)
                {
                    if (!retrogradeSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString(), retrograde));
            }
            for (int i = 0; i < 24; i++)
            {
                List<PitchClass24> retrogradeInverse = Transpose(Retrograde(Invert(pcseg)), i);
                HashSet<PitchClass24> riSet = ToPcSet(retrogradeInverse);
                bool isValid = true;

                foreach (PitchClass24 pc in pitches)
                {
                    if (!riSet.Contains(pc))
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                    secondaryForms.Add(new Pair<string, List<PitchClass24>>('T' + i.ToString(), retrogradeInverse));
            }
            return secondaryForms;
        }

        /// <summary>
        /// Gets the IMB_n of a pcseg. The IMB_n is the segment of imbricated set-classes of cardinality n.
        /// </summary>
        /// <param name="pcseg">The pcseg</param>
        /// <returns>The IMB_n</returns>
        public static List<PcSetClass> imb_n(List<PitchClass> pcseg, uint n, Dictionary<string, string>[] nameTables)
        {
            List<PitchClass> imbList = new List<PitchClass>();
            List<PcSetClass> scs = new List<PcSetClass>();
            for (int i = 0; i < pcseg.Count + 1 - n; i++)
            {
                for (int j = i; j < i + n; j++)
                    imbList.Add(pcseg[j]);
                scs.Add(new PcSetClass(imbList, nameTables));
                imbList.Clear();
            }

            return scs;
        }

        /// <summary>
        /// Gets the IMB_n of a pcseg. The IMB_n is the segment of imbricated set-classes of cardinality n.
        /// </summary>
        /// <param name="pcseg">The pcseg</param>
        /// <returns>The IMB_n</returns>
        public static List<PcSetClass24> imb_n(List<PitchClass24> pcseg, uint n)
        {
            List<PitchClass24> imbList = new List<PitchClass24>();
            List<PcSetClass24> scs = new List<PcSetClass24>();
            for (int i = 0; i < pcseg.Count + 1 - n; i++)
            {
                for (int j = i; j < i + n; j++)
                    imbList.Add(pcseg[j]);
                scs.Add(new PcSetClass24(imbList));
                imbList.Clear();
            }

            return scs;
        }

        /// <summary>
        /// Gets the interval string of a pcseg
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>The interval string</returns>
        public static List<PitchClass> Intervals(List<PitchClass> pcseg)
        {
            List<PitchClass> list = new List<PitchClass>();
            for (int i = 1; i < pcseg.Count; i++)
                list.Add(pcseg[i] - pcseg[i - 1]);
            return list;
        }

        /// <summary>
        /// Gets the interval string of a pcseg
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>The interval string</returns>
        public static List<PitchClass24> Intervals(List<PitchClass24> pcseg)
        {
            List<PitchClass24> list = new List<PitchClass24>();
            for (int i = 1; i < pcseg.Count; i++)
                list.Add(pcseg[i] - pcseg[i - 1]);
            return list;
        }

        /// <summary>
        /// Inverts a list of pitch classes without changing the original order. This is a TTO.
        /// </summary>
        /// <param name="listToInvert">The list to invert</param>
        /// <returns></returns>
        public static List<PitchClass> Invert(List<PitchClass> listToInvert)
        {
            List<PitchClass> inverted = new List<PitchClass>(listToInvert.Count);
            for (int i = 0; i < listToInvert.Count; i++)
                inverted.Add(new PitchClass(listToInvert[i].PitchClassInteger * 11));
            return inverted;
        }

        /// <summary>
        /// Inverts a list of pitch classes without changing the original order. This is a TTO.
        /// </summary>
        /// <param name="listToInvert">The list to invert</param>
        /// <returns></returns>
        public static List<PitchClass24> Invert(List<PitchClass24> listToInvert)
        {
            List<PitchClass24> inverted = new List<PitchClass24>(listToInvert.Count);
            for (int i = 0; i < listToInvert.Count; i++)
                inverted.Add(new PitchClass24(listToInvert[i].PitchClassInteger * 23));
            return inverted;
        }

        /// <summary>
        /// Determines if an interval row would produce a valid pc row or subseg of a pc row.
        /// </summary>
        /// <param name="intervalRow">The interval row</param>
        /// <returns></returns>
        public static bool IsValidRowGen(List<int> intervalRow)
        {
            // Rows longer than 11 cannot be valid pc row generators
            if (intervalRow.Count > 11)
                return false;

            for (int i = 0; i < intervalRow.Count; i++)
            {
                // Consecutive sums that equal 0 mod 12 indicate invalid row generators
                if (intervalRow[i] % 12 == 0)
                    return false;
                else
                {
                    int sum = intervalRow[i];
                    for (int j = i + 1; j < intervalRow.Count; j++)
                    {
                        sum += intervalRow[j];
                        if (sum % 12 == 0)
                            return false;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Validates potential transformation names
        /// </summary>
        /// <param name="transformationName">The transformation name</param>
        /// <returns>True if the name is valid; false otherwise</returns>
        public static bool IsValidTransformation(string transformationName)
        {
            char[] VALID_OPS = new char[5] { 'T', 'R', 'I', 'r', 'M' };
            char[] VALID_CHARS = new char[6] { 'T', 'R', 'I', 'r', 'M', '-' };
            if (transformationName.Length == 0)
                return false;
            if (System.Array.Find(VALID_OPS, (a) => a == transformationName[0]) == -1)
                return false;
            for (int i = 0; i < transformationName.Length; i++)
            {
                char c = transformationName[i];

                // T, r, and M transformations must be followed by a number
                if (c == 'T' || c == 'M' || c == 'r')
                {
                    if (i + 1 < transformationName.Length)
                    {
                        if (i + 2 < transformationName.Length)
                        {
                            if (transformationName[i + 1] == '-' && (transformationName[i + 2] < '0' || transformationName[i + 2] > '9'))
                                return false;
                        }
                        else if (transformationName[i + 1] < '0' || transformationName[i + 1] > '9')
                            return false;
                    }
                    else
                        return false;
                }

                // R and I transformations must not be followed by a number
                else if (c == 'R' || c == 'I')
                {
                    if (i + 1 < transformationName.Length)
                    {
                        if (System.Array.Find(VALID_OPS, (a) => a == transformationName[i + 1]) == -1)
                            return false;
                    }
                }

                // If the current character is not a number or a valid op, the transformation string is invalid
                else if (System.Array.Find(VALID_CHARS, (a) => a == c) == -1 && c < '0' && c > '9')
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Multiplies a pitch class list without changing the original order. This is a TTO if the multiplier is 1, 5, 7, or 11 (mod 12).
        /// </summary>
        /// <param name="listToMultiply">The list to multiply</param>
        /// <param name="multiplier">The multiplier (by default, 5). Note that multipliers other than 1, 5, 7, or 11 
        /// (mod 12) result in epimorphisms.</param>
        /// <returns>The multiplied list</returns>
        public static List<PitchClass> Multiply(List<PitchClass> listToMultiply, int multiplier = 5)
        {
            List<PitchClass> multiplied = new List<PitchClass>(listToMultiply.Count);
            for (int i = 0; i < listToMultiply.Count; i++)
                multiplied.Add(new PitchClass(listToMultiply[i].PitchClassInteger * multiplier));
            return multiplied;
        }

        /// <summary>
        /// Multiplies a pitch class list without changing the original order. This is a TTO if the multiplier is 1, 5, 7, or 11 (mod 12).
        /// </summary>
        /// <param name="listToMultiply">The list to multiply</param>
        /// <param name="multiplier">The multiplier (by default, 5). Note that multipliers other than 1, 5, 7, or 11 
        /// (mod 12) result in epimorphisms.</param>
        /// <returns>The multiplied list</returns>
        public static List<PitchClass24> Multiply(List<PitchClass24> listToMultiply, int multiplier = 5)
        {
            List<PitchClass24> multiplied = new List<PitchClass24>(listToMultiply.Count);
            for (int i = 0; i < listToMultiply.Count; i++)
                multiplied.Add(new PitchClass24(listToMultiply[i].PitchClassInteger * multiplier));
            return multiplied;
        }

        /// <summary>
        /// Generates a pitch class list from a provided string
        /// </summary>
        /// <param name="pitches">A string of pitch classes</param>
        /// <returns>A pitch class list</returns>
        public static List<PitchClass> Parse(string pitches)
        {
            List<PitchClass> list = new List<PitchClass>();
            foreach (char p in pitches)
            {
                if (p < '0' || (p > '9' && p != 'a' && p != 'A' && p != 'b' && p != 'B'))
                {
                    list.Clear();
                    break;
                }
                list.Add(new PitchClass(p));
            }
            return list;
        }

        /// <summary>
        /// Generates a pitch class list from a provided string
        /// </summary>
        /// <param name="pitches">A string of pitch classes</param>
        /// <returns>A pitch class list</returns>
        public static List<PitchClass24> Parse24(string pitches)
        {
            List<PitchClass24> list = new List<PitchClass24>();
            string[] split = pitches.Split(", ");
            if (split.Length == 1)
                split = split[0].Split(",");

            foreach (string str in split)
                list.Add(new PitchClass24(int.Parse(str)));
            return list;
        }

        /// <summary>
        /// Retrogrades a PcSeg
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>A retrograded pcseg</returns>
        public static List<PitchClass> Retrograde(List<PitchClass> pcseg)
        {
            List<PitchClass> list = CopyList(pcseg);
            list.Reverse();
            return list;
        }

        /// <summary>
        /// Retrogrades a PcSeg
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>A retrograded pcseg</returns>
        public static List<PitchClass24> Retrograde(List<PitchClass24> pcseg)
        {
            List<PitchClass24> list = CopyList(pcseg);
            list.Reverse();
            return list;
        }

        /// <summary>
        /// Rotates a PcSeg
        /// </summary>
        /// <param name="i">The index of rotation</param>
        public static List<PitchClass> Rotate(List<PitchClass> pcseg, int i)
        {
            List<PitchClass> newList = new List<PitchClass>(pcseg.Capacity);
            if (i < 0)
                i = ((i % pcseg.Count) + pcseg.Count) % pcseg.Count;
            for (int j = 0; j < pcseg.Count; j++)
                newList.Add(pcseg[(j - i + pcseg.Count) % pcseg.Count]);
            return newList;
        }

        /// <summary>
        /// Rotates a PcSeg
        /// </summary>
        /// <param name="i">The index of rotation</param>
        public static List<PitchClass24> Rotate(List<PitchClass24> pcseg, int i)
        {
            List<PitchClass24> newList = new List<PitchClass24>(pcseg.Capacity);
            if (i < 0)
                i = ((i % pcseg.Count) + pcseg.Count) % pcseg.Count;
            for (int j = 0; j < pcseg.Count; j++)
                newList.Add(pcseg[(j - i + pcseg.Count) % pcseg.Count]);
            return newList;
        }

        /// <summary>
        /// Sorts a pc list
        /// </summary>
        /// <param name="pcseg">The list</param>
        /// <returns>A sorted copy of the list</returns>
        public static List<PitchClass> Sort(List<PitchClass> pcseg)
        {
            List<PitchClass> newList = new List<PitchClass>();
            foreach (PitchClass pc in pcseg)
                newList.Add(new PitchClass(pc));
            newList.Sort((a, b) => a.PitchClassInteger.CompareTo(b.PitchClassInteger));
            return newList;
        }

        /// <summary>
        /// Sorts a pc list
        /// </summary>
        /// <param name="pcseg">The list</param>
        /// <returns>A sorted copy of the list</returns>
        public static List<PitchClass24> Sort(List<PitchClass24> pcseg)
        {
            List<PitchClass24> newList = new List<PitchClass24>();
            foreach (PitchClass24 pc in pcseg)
                newList.Add(new PitchClass24(pc));
            newList.Sort((a, b) => a.PitchClassInteger.CompareTo(b.PitchClassInteger));
            return newList;
        }

        /// <summary>
        /// Sorts a list of pcsegs
        /// </summary>
        /// <param name="listToSort">The list to sort</param>
        /// <returns>A sorted copy</returns>
        public static List<List<PitchClass>> SortPcsegList(List<List<PitchClass>> listToSort)
        {
            List<Pair<int, List<PitchClass>>> sortKey = new List<Pair<int, List<PitchClass>>>();
            List<List<PitchClass>> sorted = new List<List<PitchClass>>();
            foreach (List<PitchClass> pcseg in listToSort)
            {
                if (pcseg.Count == 0)
                    sortKey.Add(new Pair<int, List<PitchClass>>(-1, pcseg));
                else
                    sortKey.Add(new Pair<int, List<PitchClass>>(int.Parse(ToString(pcseg, "", false)), pcseg));
            }
            sortKey.Sort((a, b) => a.Item1.CompareTo(b.Item1));
            foreach (Pair<int, List<PitchClass>> pair in sortKey)
                sorted.Add(pair.Item2);
            return sorted;
        }

        /// <summary>
        /// Sorts a list of pcsegs
        /// </summary>
        /// <param name="listToSort">The list to sort</param>
        /// <returns>A sorted copy</returns>
        public static List<List<PitchClass24>> SortPcsegList(List<List<PitchClass24>> listToSort)
        {
            List<Pair<long, List<PitchClass24>>> sortKey = new List<Pair<long, List<PitchClass24>>>();
            List<List<PitchClass24>> sorted = new List<List<PitchClass24>>();
            foreach (List<PitchClass24> pcseg in listToSort)
            {
                if (pcseg.Count == 0)
                    sortKey.Add(new Pair<long, List<PitchClass24>>(-1, pcseg));
                else
                    sortKey.Add(new Pair<long, List<PitchClass24>>(long.Parse(ToString(pcseg, "")), pcseg));
            }
            sortKey.Sort((a, b) => a.Item1.CompareTo(b.Item1));
            foreach (Pair<long, List<PitchClass24>> pair in sortKey)
                sorted.Add(pair.Item2);
            return sorted;
        }

        /// <summary>
        /// Gets all subsegs of a pcseg
        /// Uses the bit vector solution from https://www.geeksforgeeks.org/power-set/
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>The subsets of the pcseg</returns>
        public static List<List<PitchClass>> Subsegs(List<PitchClass> pcseg)
        {
            List<List<PitchClass>> subsegs = new List<List<PitchClass>>();
            int size = (int)System.Math.Pow(2, pcseg.Count);

            for (int i = 1; i < size; i++)
            {
                subsegs.Add(new List<PitchClass>());
                for (int j = 0; j < pcseg.Count; j++)
                {
                    if ((i & (1 << j)) > 0)
                        subsegs[subsegs.Count - 1].Add(pcseg[j]);
                }
            }

            return subsegs;
        }

        /// <summary>
        /// Gets all subsegs of a pcseg
        /// Uses the bit vector solution from https://www.geeksforgeeks.org/power-set/
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>The subsets of the pcseg</returns>
        public static List<List<PitchClass24>> Subsegs(List<PitchClass24> pcseg)
        {
            List<List<PitchClass24>> subsegs = new List<List<PitchClass24>>();
            int size = (int)System.Math.Pow(2, pcseg.Count);

            for (int i = 1; i < size; i++)
            {
                subsegs.Add(new List<PitchClass24>());
                for (int j = 0; j < pcseg.Count; j++)
                {
                    if ((i & (1 << j)) > 0)
                        subsegs[subsegs.Count - 1].Add(pcseg[j]);
                }
            }

            return subsegs;
        }

        /// <summary>
        /// Gets all subsegs of a pcseg
        /// </summary>
        /// <param name="pcseg">A pcseg</param>
        /// <returns>The subsets of the pcseg</returns>
        [System.Obsolete("This method is deprecated")]
        private static List<List<PitchClass>> SubsegsOld(List<PitchClass> pcseg)
        {
            List<List<PitchClass>> store = new List<List<PitchClass>>();
            List<PitchClass> build = new List<PitchClass>();
            List<PitchClass> remaining = new List<PitchClass>(pcseg);

            for (int i = 1; i < pcseg.Count; i++)
                SubsegsHelper(store, build, remaining, 0, i);

            return store;
        }

        /// <summary>
        /// A helper for Subsegs
        /// </summary>
        /// <param name="store">The list to store completed subsegs</param>
        /// <param name="build">The current subseg we are building</param>
        /// <param name="remaining">The remaining pitch classes from which to choose</param>
        /// <param name="selected">The number of pitch classes already chosen</param>
        /// <param name="max">The maximum number of pitch classes to choose</param>
        [System.Obsolete("This method is deprecated")]
        private static void SubsegsHelper(List<List<PitchClass>> store, List<PitchClass> build, List<PitchClass> remaining, int selected, int max)
        {
            if (selected == max)
                store.Add(build);
            else
            {
                for (int i = 0; i <= remaining.Count - max + selected; i++)
                {
                    List<PitchClass> newBuild = new List<PitchClass>(build);
                    List<PitchClass> newRemaining = new List<PitchClass>(remaining);
                    newBuild.Add(new PitchClass(newRemaining[i]));
                    newRemaining.RemoveRange(0, i + 1);
                    SubsegsHelper(store, newBuild, newRemaining, selected + 1, max);
                }
            }
        }

        /// <summary>
        /// Converts a pitch-class list to an integer list
        /// </summary>
        /// <param name="list">The list</param>
        /// <returns>An integer list</returns>
        public static List<int> ToIntList(List<PitchClass> list)
        {
            List<int> newList = new List<int>();
            foreach (PitchClass pc in list)
                newList.Add(pc.PitchClassInteger);
            return newList;
        }

        /// <summary>
        /// Converts a pitch-class list to an integer list
        /// </summary>
        /// <param name="list">The list</param>
        /// <returns>An integer list</returns>
        public static List<int> ToIntList(List<PitchClass24> list)
        {
            List<int> newList = new List<int>();
            foreach (PitchClass24 pc in list)
                newList.Add(pc.PitchClassInteger);
            return newList;
        }

        /// <summary>
        /// Converts a pitch-class list to a HashSet
        /// </summary>
        /// <param name="list">The list</param>
        /// <returns>A HashSet</returns>
        public static HashSet<PitchClass> ToPcSet(List<PitchClass> list)
        {
            HashSet<PitchClass> set = new HashSet<PitchClass>();
            foreach (PitchClass pc in list)
                set.Add(new PitchClass(pc));
            return set;
        }

        /// <summary>
        /// Converts a pitch-class list to a HashSet
        /// </summary>
        /// <param name="list">The list</param>
        /// <returns>A HashSet</returns>
        public static HashSet<PitchClass24> ToPcSet(List<PitchClass24> list)
        {
            HashSet<PitchClass24> set = new HashSet<PitchClass24>();
            foreach (PitchClass24 pc in list)
                set.Add(new PitchClass24(pc));
            return set;
        }

        /// <summary>
        /// Converts a pitch-class list to a string
        /// </summary>
        /// <param name="list">The pitch-class list</param>
        /// <param name="useChar">Whether or not to use characters or strings</param>
        /// <returns>A string</returns>
        public static string ToString(List<PitchClass> list, string separator = "", bool useChar = true)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            if (useChar)
            {
                for (int i = 0; i < list.Count - 1; i++)
                    sb.Append(list[i].PitchClassChar + separator);
                if (list.Count > 0)
                    sb.Append(list[list.Count - 1].PitchClassChar);
            }
            else
            {
                for (int i = 0; i < list.Count - 1; i++)
                    sb.Append(list[i].PitchClassString + separator);
                if (list.Count > 0)
                    sb.Append(list[list.Count - 1].PitchClassString);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts a pitch-class list to a string
        /// </summary>
        /// <param name="list">The pitch-class list</param>
        /// <returns>A string</returns>
        public static string ToString(List<PitchClass24> list, string separator = ", ")
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            for (int i = 0; i < list.Count - 1; i++)
                sb.Append(list[i].PitchClassString + separator);
            if (list.Count > 0)
                sb.Append(list[list.Count - 1].PitchClassString);
            return sb.ToString();
        }

        /// <summary>
        /// Transforms a pcseg
        /// </summary>
        /// <param name="transformationString">The transformation name</param>
        /// <returns>The transformed pcseg</returns>
        public static List<PitchClass> Transform(List<PitchClass> pcseg, string transformationString)
        {
            List<Pair<char, int>> opList = new List<Pair<char, int>>();
            List<PitchClass> transform = pcseg;
            int numCount = 0;
            char[] VALID_OPS = new char[5] { 'T', 'R', 'I', 'r', 'M' };
            opList.Add(new Pair<char, int>('0', 0));

            // Parse the transformation string and separate it into opcodes and numbers
            for (int i = transformationString.Length - 1; i >= 0; i--)
            {
                char c = transformationString[i];
                if (c >= '0' && c <= '9')
                {
                    opList[opList.Count - 1].Item2 += (int)System.Math.Pow(10, numCount) * (c - '0');
                    numCount++;
                }
                else if (c == '-' && i > 0)
                    opList[opList.Count - 1].Item2 *= -1;
                else
                {
                    if (System.Array.Find(VALID_OPS, (a) => a == c) != -1)
                    {
                        opList[opList.Count - 1].Item1 = c;
                        if (i > 0)
                            opList.Add(new Pair<char, int>('0', 0));
                    }
                    numCount = 0;
                }
            }

            // Perform the transformation
            foreach (Pair<char, int> pair in opList)
            {
                if (pair.Item1 == 'T')
                    transform = Transpose(transform, pair.Item2);
                else if (pair.Item1 == 'R')
                    transform = Retrograde(transform);
                else if (pair.Item1 == 'I')
                    transform = Invert(transform);
                else if (pair.Item1 == 'r')
                    transform = Rotate(transform, pair.Item2);
                else if (pair.Item1 == 'M')
                    transform = Multiply(transform, pair.Item2);
            }

            return transform;
        }

        /// <summary>
        /// Transforms a pcseg
        /// </summary>
        /// <param name="transformationString">The transformation name</param>
        /// <returns>The transformed pcseg</returns>
        public static List<PitchClass24> Transform(List<PitchClass24> pcseg, string transformationString)
        {
            List<Pair<char, int>> opList = new List<Pair<char, int>>();
            List<PitchClass24> transform = pcseg;
            int numCount = 0;
            char[] VALID_OPS = new char[5] { 'T', 'R', 'I', 'r', 'M' };
            opList.Add(new Pair<char, int>('0', 0));

            // Parse the transformation string and separate it into opcodes and numbers
            for (int i = transformationString.Length - 1; i >= 0; i--)
            {
                char c = transformationString[i];
                if (c >= '0' && c <= '9')
                {
                    opList[opList.Count - 1].Item2 += (int)System.Math.Pow(10, numCount) * (c - '0');
                    numCount++;
                }
                else if (c == '-' && i > 0)
                    opList[opList.Count - 1].Item2 *= -1;
                else
                {
                    if (System.Array.Find(VALID_OPS, (a) => a == c) != -1)
                    {
                        opList[opList.Count - 1].Item1 = c;
                        if (i > 0)
                            opList.Add(new Pair<char, int>('0', 0));
                    }
                    numCount = 0;
                }
            }

            // Perform the transformation
            foreach (Pair<char, int> pair in opList)
            {
                if (pair.Item1 == 'T')
                    transform = Transpose(transform, pair.Item2);
                else if (pair.Item1 == 'R')
                    transform = Retrograde(transform);
                else if (pair.Item1 == 'I')
                    transform = Invert(transform);
                else if (pair.Item1 == 'r')
                    transform = Rotate(transform, pair.Item2);
                else if (pair.Item1 == 'M')
                    transform = Multiply(transform, pair.Item2);
            }

            return transform;
        }

        /// <summary>
        /// Transposes a list of pitch classes without changing the original order. This is a TTO.
        /// </summary>
        /// <param name="listToTranspose">The list to transpose</param>
        /// <param name="numberOfTranspositions">The number of transpositions</param>
        /// <returns>The transposed list</returns>
        public static List<PitchClass> Transpose(List<PitchClass> listToTranspose, int numberOfTranspositions)
        {
            List<PitchClass> transposedList = new List<PitchClass>(listToTranspose.Count);
            for (int i = 0; i < listToTranspose.Count; i++)
                transposedList.Add(new PitchClass(listToTranspose[i].PitchClassInteger + numberOfTranspositions));
            return transposedList;
        }

        /// <summary>
        /// Transposes a list of pitch classes without changing the original order. This is a TTO.
        /// </summary>
        /// <param name="listToTranspose">The list to transpose</param>
        /// <param name="numberOfTranspositions">The number of transpositions</param>
        /// <returns>The transposed list</returns>
        public static List<PitchClass24> Transpose(List<PitchClass24> listToTranspose, int numberOfTranspositions)
        {
            List<PitchClass24> transposedList = new List<PitchClass24>(listToTranspose.Count);
            for (int i = 0; i < listToTranspose.Count; i++)
                transposedList.Add(new PitchClass24(listToTranspose[i].PitchClassInteger + numberOfTranspositions));
            return transposedList;
        }
    }
}
